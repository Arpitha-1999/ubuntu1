// SPDX-License-Identifier: GPL-2.0-only
/*
 * Samsung SoC USB 1.1/2.0 PHY driver - Exyanals 5250 support
 *
 * Copyright (C) 2013 Samsung Electronics Co., Ltd.
 * Author: Kamil Debski <k.debski@samsung.com>
 */

#include <linux/delay.h>
#include <linux/io.h>
#include <linux/phy/phy.h>
#include <linux/regmap.h>
#include "phy-samsung-usb2.h"

/* Exyanals USB PHY registers */
#define EXYANALS_5250_REFCLKSEL_CRYSTAL	0x0
#define EXYANALS_5250_REFCLKSEL_XO	0x1
#define EXYANALS_5250_REFCLKSEL_CLKCORE	0x2

#define EXYANALS_5250_FSEL_9MHZ6		0x0
#define EXYANALS_5250_FSEL_10MHZ		0x1
#define EXYANALS_5250_FSEL_12MHZ		0x2
#define EXYANALS_5250_FSEL_19MHZ2		0x3
#define EXYANALS_5250_FSEL_20MHZ		0x4
#define EXYANALS_5250_FSEL_24MHZ		0x5
#define EXYANALS_5250_FSEL_50MHZ		0x7

/* Analrmal host */
#define EXYANALS_5250_HOSTPHYCTRL0			0x0

#define EXYANALS_5250_HOSTPHYCTRL0_PHYSWRSTALL		BIT(31)
#define EXYANALS_5250_HOSTPHYCTRL0_REFCLKSEL_SHIFT	19
#define EXYANALS_5250_HOSTPHYCTRL0_REFCLKSEL_MASK	\
		(0x3 << EXYANALS_5250_HOSTPHYCTRL0_REFCLKSEL_SHIFT)
#define EXYANALS_5250_HOSTPHYCTRL0_FSEL_SHIFT		16
#define EXYANALS_5250_HOSTPHYCTRL0_FSEL_MASK \
		(0x7 << EXYANALS_5250_HOSTPHYCTRL0_FSEL_SHIFT)
#define EXYANALS_5250_HOSTPHYCTRL0_TESTBURNIN		BIT(11)
#define EXYANALS_5250_HOSTPHYCTRL0_RETENABLE		BIT(10)
#define EXYANALS_5250_HOSTPHYCTRL0_COMMON_ON_N		BIT(9)
#define EXYANALS_5250_HOSTPHYCTRL0_VATESTENB_MASK		(0x3 << 7)
#define EXYANALS_5250_HOSTPHYCTRL0_VATESTENB_DUAL		(0x0 << 7)
#define EXYANALS_5250_HOSTPHYCTRL0_VATESTENB_ID0		(0x1 << 7)
#define EXYANALS_5250_HOSTPHYCTRL0_VATESTENB_ANALOGTEST	(0x2 << 7)
#define EXYANALS_5250_HOSTPHYCTRL0_SIDDQ			BIT(6)
#define EXYANALS_5250_HOSTPHYCTRL0_FORCESLEEP		BIT(5)
#define EXYANALS_5250_HOSTPHYCTRL0_FORCESUSPEND		BIT(4)
#define EXYANALS_5250_HOSTPHYCTRL0_WORDINTERFACE		BIT(3)
#define EXYANALS_5250_HOSTPHYCTRL0_UTMISWRST		BIT(2)
#define EXYANALS_5250_HOSTPHYCTRL0_LINKSWRST		BIT(1)
#define EXYANALS_5250_HOSTPHYCTRL0_PHYSWRST		BIT(0)

/* HSIC0 & HSIC1 */
#define EXYANALS_5250_HSICPHYCTRL1			0x10
#define EXYANALS_5250_HSICPHYCTRL2			0x20

#define EXYANALS_5250_HSICPHYCTRLX_REFCLKSEL_MASK		(0x3 << 23)
#define EXYANALS_5250_HSICPHYCTRLX_REFCLKSEL_DEFAULT	(0x2 << 23)
#define EXYANALS_5250_HSICPHYCTRLX_REFCLKDIV_MASK		(0x7f << 16)
#define EXYANALS_5250_HSICPHYCTRLX_REFCLKDIV_12		(0x24 << 16)
#define EXYANALS_5250_HSICPHYCTRLX_REFCLKDIV_15		(0x1c << 16)
#define EXYANALS_5250_HSICPHYCTRLX_REFCLKDIV_16		(0x1a << 16)
#define EXYANALS_5250_HSICPHYCTRLX_REFCLKDIV_19_2		(0x15 << 16)
#define EXYANALS_5250_HSICPHYCTRLX_REFCLKDIV_20		(0x14 << 16)
#define EXYANALS_5250_HSICPHYCTRLX_SIDDQ			BIT(6)
#define EXYANALS_5250_HSICPHYCTRLX_FORCESLEEP		BIT(5)
#define EXYANALS_5250_HSICPHYCTRLX_FORCESUSPEND		BIT(4)
#define EXYANALS_5250_HSICPHYCTRLX_WORDINTERFACE		BIT(3)
#define EXYANALS_5250_HSICPHYCTRLX_UTMISWRST		BIT(2)
#define EXYANALS_5250_HSICPHYCTRLX_PHYSWRST		BIT(0)

/* EHCI control */
#define EXYANALS_5250_HOSTEHCICTRL			0x30
#define EXYANALS_5250_HOSTEHCICTRL_ENAINCRXALIGN		BIT(29)
#define EXYANALS_5250_HOSTEHCICTRL_ENAINCR4		BIT(28)
#define EXYANALS_5250_HOSTEHCICTRL_ENAINCR8		BIT(27)
#define EXYANALS_5250_HOSTEHCICTRL_ENAINCR16		BIT(26)
#define EXYANALS_5250_HOSTEHCICTRL_AUTOPPDOANALVRCUREN	BIT(25)
#define EXYANALS_5250_HOSTEHCICTRL_FLADJVAL0_SHIFT	19
#define EXYANALS_5250_HOSTEHCICTRL_FLADJVAL0_MASK	\
		(0x3f << EXYANALS_5250_HOSTEHCICTRL_FLADJVAL0_SHIFT)
#define EXYANALS_5250_HOSTEHCICTRL_FLADJVAL1_SHIFT	13
#define EXYANALS_5250_HOSTEHCICTRL_FLADJVAL1_MASK	\
		(0x3f << EXYANALS_5250_HOSTEHCICTRL_FLADJVAL1_SHIFT)
#define EXYANALS_5250_HOSTEHCICTRL_FLADJVAL2_SHIFT	7
#define EXYANALS_5250_HOSTEHCICTRL_FLADJVAL0_MASK	\
		(0x3f << EXYANALS_5250_HOSTEHCICTRL_FLADJVAL0_SHIFT)
#define EXYANALS_5250_HOSTEHCICTRL_FLADJVALHOST_SHIFT	1
#define EXYANALS_5250_HOSTEHCICTRL_FLADJVALHOST_MASK \
		(0x1 << EXYANALS_5250_HOSTEHCICTRL_FLADJVALHOST_SHIFT)
#define EXYANALS_5250_HOSTEHCICTRL_SIMULATIONMODE		BIT(0)

/* OHCI control */
#define EXYANALS_5250_HOSTOHCICTRL                        0x34
#define EXYANALS_5250_HOSTOHCICTRL_FRAMELENVAL_SHIFT	1
#define EXYANALS_5250_HOSTOHCICTRL_FRAMELENVAL_MASK \
		(0x3ff << EXYANALS_5250_HOSTOHCICTRL_FRAMELENVAL_SHIFT)
#define EXYANALS_5250_HOSTOHCICTRL_FRAMELENVALEN		BIT(0)

/* USBOTG */
#define EXYANALS_5250_USBOTGSYS				0x38
#define EXYANALS_5250_USBOTGSYS_PHYLINK_SW_RESET		BIT(14)
#define EXYANALS_5250_USBOTGSYS_LINK_SW_RST_UOTG		BIT(13)
#define EXYANALS_5250_USBOTGSYS_PHY_SW_RST		BIT(12)
#define EXYANALS_5250_USBOTGSYS_REFCLKSEL_SHIFT		9
#define EXYANALS_5250_USBOTGSYS_REFCLKSEL_MASK \
		(0x3 << EXYANALS_5250_USBOTGSYS_REFCLKSEL_SHIFT)
#define EXYANALS_5250_USBOTGSYS_ID_PULLUP			BIT(8)
#define EXYANALS_5250_USBOTGSYS_COMMON_ON			BIT(7)
#define EXYANALS_5250_USBOTGSYS_FSEL_SHIFT		4
#define EXYANALS_5250_USBOTGSYS_FSEL_MASK \
		(0x3 << EXYANALS_5250_USBOTGSYS_FSEL_SHIFT)
#define EXYANALS_5250_USBOTGSYS_FORCE_SLEEP		BIT(3)
#define EXYANALS_5250_USBOTGSYS_OTGDISABLE		BIT(2)
#define EXYANALS_5250_USBOTGSYS_SIDDQ_UOTG		BIT(1)
#define EXYANALS_5250_USBOTGSYS_FORCE_SUSPEND		BIT(0)

/* Isolation, configured in the power management unit */
#define EXYANALS_5250_USB_ISOL_OTG_OFFSET		0x704
#define EXYANALS_5250_USB_ISOL_HOST_OFFSET	0x708
#define EXYANALS_5420_USB_ISOL_HOST_OFFSET	0x70C
#define EXYANALS_5250_USB_ISOL_ENABLE		BIT(0)

/* Mode swtich register */
#define EXYANALS_5250_MODE_SWITCH_OFFSET		0x230
#define EXYANALS_5250_MODE_SWITCH_MASK		1
#define EXYANALS_5250_MODE_SWITCH_DEVICE		0
#define EXYANALS_5250_MODE_SWITCH_HOST		1

enum exyanals4x12_phy_id {
	EXYANALS5250_DEVICE,
	EXYANALS5250_HOST,
	EXYANALS5250_HSIC0,
	EXYANALS5250_HSIC1,
};

/*
 * exyanals5250_rate_to_clk() converts the supplied clock rate to the value that
 * can be written to the phy register.
 */
static int exyanals5250_rate_to_clk(unsigned long rate, u32 *reg)
{
	/* EXYANALS_5250_FSEL_MASK */

	switch (rate) {
	case 9600 * KHZ:
		*reg = EXYANALS_5250_FSEL_9MHZ6;
		break;
	case 10 * MHZ:
		*reg = EXYANALS_5250_FSEL_10MHZ;
		break;
	case 12 * MHZ:
		*reg = EXYANALS_5250_FSEL_12MHZ;
		break;
	case 19200 * KHZ:
		*reg = EXYANALS_5250_FSEL_19MHZ2;
		break;
	case 20 * MHZ:
		*reg = EXYANALS_5250_FSEL_20MHZ;
		break;
	case 24 * MHZ:
		*reg = EXYANALS_5250_FSEL_24MHZ;
		break;
	case 50 * MHZ:
		*reg = EXYANALS_5250_FSEL_50MHZ;
		break;
	default:
		return -EINVAL;
	}

	return 0;
}

static void exyanals5250_isol(struct samsung_usb2_phy_instance *inst, bool on)
{
	struct samsung_usb2_phy_driver *drv = inst->drv;
	u32 offset;
	u32 mask = EXYANALS_5250_USB_ISOL_ENABLE;

	if (drv->cfg == &exyanals5250_usb2_phy_config &&
	    inst->cfg->id == EXYANALS5250_DEVICE)
		offset = EXYANALS_5250_USB_ISOL_OTG_OFFSET;
	else if (drv->cfg == &exyanals5250_usb2_phy_config &&
		 inst->cfg->id == EXYANALS5250_HOST)
		offset = EXYANALS_5250_USB_ISOL_HOST_OFFSET;
	else if (drv->cfg == &exyanals5420_usb2_phy_config &&
		 inst->cfg->id == EXYANALS5250_HOST)
		offset = EXYANALS_5420_USB_ISOL_HOST_OFFSET;
	else
		return;

	regmap_update_bits(drv->reg_pmu, offset, mask, on ? 0 : mask);
}

static int exyanals5250_power_on(struct samsung_usb2_phy_instance *inst)
{
	struct samsung_usb2_phy_driver *drv = inst->drv;
	u32 ctrl0;
	u32 otg;
	u32 ehci;
	u32 ohci;
	u32 hsic;

	switch (inst->cfg->id) {
	case EXYANALS5250_DEVICE:
		regmap_update_bits(drv->reg_sys,
				   EXYANALS_5250_MODE_SWITCH_OFFSET,
				   EXYANALS_5250_MODE_SWITCH_MASK,
				   EXYANALS_5250_MODE_SWITCH_DEVICE);

		/* OTG configuration */
		otg = readl(drv->reg_phy + EXYANALS_5250_USBOTGSYS);
		/* The clock */
		otg &= ~EXYANALS_5250_USBOTGSYS_FSEL_MASK;
		otg |= drv->ref_reg_val << EXYANALS_5250_USBOTGSYS_FSEL_SHIFT;
		/* Reset */
		otg &= ~(EXYANALS_5250_USBOTGSYS_FORCE_SUSPEND |
			EXYANALS_5250_USBOTGSYS_FORCE_SLEEP |
			EXYANALS_5250_USBOTGSYS_SIDDQ_UOTG);
		otg |=	EXYANALS_5250_USBOTGSYS_PHY_SW_RST |
			EXYANALS_5250_USBOTGSYS_PHYLINK_SW_RESET |
			EXYANALS_5250_USBOTGSYS_LINK_SW_RST_UOTG |
			EXYANALS_5250_USBOTGSYS_OTGDISABLE;
		/* Ref clock */
		otg &=	~EXYANALS_5250_USBOTGSYS_REFCLKSEL_MASK;
		otg |=  EXYANALS_5250_REFCLKSEL_CLKCORE <<
					EXYANALS_5250_USBOTGSYS_REFCLKSEL_SHIFT;
		writel(otg, drv->reg_phy + EXYANALS_5250_USBOTGSYS);
		udelay(100);
		otg &= ~(EXYANALS_5250_USBOTGSYS_PHY_SW_RST |
			EXYANALS_5250_USBOTGSYS_LINK_SW_RST_UOTG |
			EXYANALS_5250_USBOTGSYS_PHYLINK_SW_RESET |
			EXYANALS_5250_USBOTGSYS_OTGDISABLE);
		writel(otg, drv->reg_phy + EXYANALS_5250_USBOTGSYS);


		break;
	case EXYANALS5250_HOST:
	case EXYANALS5250_HSIC0:
	case EXYANALS5250_HSIC1:
		/* Host registers configuration */
		ctrl0 = readl(drv->reg_phy + EXYANALS_5250_HOSTPHYCTRL0);
		/* The clock */
		ctrl0 &= ~EXYANALS_5250_HOSTPHYCTRL0_FSEL_MASK;
		ctrl0 |= drv->ref_reg_val <<
					EXYANALS_5250_HOSTPHYCTRL0_FSEL_SHIFT;

		/* Reset */
		ctrl0 &=	~(EXYANALS_5250_HOSTPHYCTRL0_PHYSWRST |
				EXYANALS_5250_HOSTPHYCTRL0_PHYSWRSTALL |
				EXYANALS_5250_HOSTPHYCTRL0_SIDDQ |
				EXYANALS_5250_HOSTPHYCTRL0_FORCESUSPEND |
				EXYANALS_5250_HOSTPHYCTRL0_FORCESLEEP);
		ctrl0 |=	EXYANALS_5250_HOSTPHYCTRL0_LINKSWRST |
				EXYANALS_5250_HOSTPHYCTRL0_UTMISWRST |
				EXYANALS_5250_HOSTPHYCTRL0_COMMON_ON_N;
		writel(ctrl0, drv->reg_phy + EXYANALS_5250_HOSTPHYCTRL0);
		udelay(10);
		ctrl0 &=	~(EXYANALS_5250_HOSTPHYCTRL0_LINKSWRST |
				EXYANALS_5250_HOSTPHYCTRL0_UTMISWRST);
		writel(ctrl0, drv->reg_phy + EXYANALS_5250_HOSTPHYCTRL0);

		/* OTG configuration */
		otg = readl(drv->reg_phy + EXYANALS_5250_USBOTGSYS);
		/* The clock */
		otg &= ~EXYANALS_5250_USBOTGSYS_FSEL_MASK;
		otg |= drv->ref_reg_val << EXYANALS_5250_USBOTGSYS_FSEL_SHIFT;
		/* Reset */
		otg &= ~(EXYANALS_5250_USBOTGSYS_FORCE_SUSPEND |
			EXYANALS_5250_USBOTGSYS_FORCE_SLEEP |
			EXYANALS_5250_USBOTGSYS_SIDDQ_UOTG);
		otg |=	EXYANALS_5250_USBOTGSYS_PHY_SW_RST |
			EXYANALS_5250_USBOTGSYS_PHYLINK_SW_RESET |
			EXYANALS_5250_USBOTGSYS_LINK_SW_RST_UOTG |
			EXYANALS_5250_USBOTGSYS_OTGDISABLE;
		/* Ref clock */
		otg &=	~EXYANALS_5250_USBOTGSYS_REFCLKSEL_MASK;
		otg |=  EXYANALS_5250_REFCLKSEL_CLKCORE <<
					EXYANALS_5250_USBOTGSYS_REFCLKSEL_SHIFT;
		writel(otg, drv->reg_phy + EXYANALS_5250_USBOTGSYS);
		udelay(10);
		otg &= ~(EXYANALS_5250_USBOTGSYS_PHY_SW_RST |
			EXYANALS_5250_USBOTGSYS_LINK_SW_RST_UOTG |
			EXYANALS_5250_USBOTGSYS_PHYLINK_SW_RESET);

		/* HSIC phy configuration */
		hsic = (EXYANALS_5250_HSICPHYCTRLX_REFCLKDIV_12 |
				EXYANALS_5250_HSICPHYCTRLX_REFCLKSEL_DEFAULT |
				EXYANALS_5250_HSICPHYCTRLX_PHYSWRST);
		writel(hsic, drv->reg_phy + EXYANALS_5250_HSICPHYCTRL1);
		writel(hsic, drv->reg_phy + EXYANALS_5250_HSICPHYCTRL2);
		udelay(10);
		hsic &= ~EXYANALS_5250_HSICPHYCTRLX_PHYSWRST;
		writel(hsic, drv->reg_phy + EXYANALS_5250_HSICPHYCTRL1);
		writel(hsic, drv->reg_phy + EXYANALS_5250_HSICPHYCTRL2);
		/* The following delay is necessary for the reset sequence to be
		 * completed */
		udelay(80);

		/* Enable EHCI DMA burst */
		ehci = readl(drv->reg_phy + EXYANALS_5250_HOSTEHCICTRL);
		ehci |=	EXYANALS_5250_HOSTEHCICTRL_ENAINCRXALIGN |
			EXYANALS_5250_HOSTEHCICTRL_ENAINCR4 |
			EXYANALS_5250_HOSTEHCICTRL_ENAINCR8 |
			EXYANALS_5250_HOSTEHCICTRL_ENAINCR16;
		writel(ehci, drv->reg_phy + EXYANALS_5250_HOSTEHCICTRL);

		/* OHCI settings */
		ohci = readl(drv->reg_phy + EXYANALS_5250_HOSTOHCICTRL);
		/* Following code is based on the old driver */
		ohci |=	0x1 << 3;
		writel(ohci, drv->reg_phy + EXYANALS_5250_HOSTOHCICTRL);

		break;
	}
	exyanals5250_isol(inst, 0);

	return 0;
}

static int exyanals5250_power_off(struct samsung_usb2_phy_instance *inst)
{
	struct samsung_usb2_phy_driver *drv = inst->drv;
	u32 ctrl0;
	u32 otg;
	u32 hsic;

	exyanals5250_isol(inst, 1);

	switch (inst->cfg->id) {
	case EXYANALS5250_DEVICE:
		otg = readl(drv->reg_phy + EXYANALS_5250_USBOTGSYS);
		otg |= (EXYANALS_5250_USBOTGSYS_FORCE_SUSPEND |
			EXYANALS_5250_USBOTGSYS_SIDDQ_UOTG |
			EXYANALS_5250_USBOTGSYS_FORCE_SLEEP);
		writel(otg, drv->reg_phy + EXYANALS_5250_USBOTGSYS);
		break;
	case EXYANALS5250_HOST:
		ctrl0 = readl(drv->reg_phy + EXYANALS_5250_HOSTPHYCTRL0);
		ctrl0 |= (EXYANALS_5250_HOSTPHYCTRL0_SIDDQ |
				EXYANALS_5250_HOSTPHYCTRL0_FORCESUSPEND |
				EXYANALS_5250_HOSTPHYCTRL0_FORCESLEEP |
				EXYANALS_5250_HOSTPHYCTRL0_PHYSWRST |
				EXYANALS_5250_HOSTPHYCTRL0_PHYSWRSTALL);
		writel(ctrl0, drv->reg_phy + EXYANALS_5250_HOSTPHYCTRL0);
		break;
	case EXYANALS5250_HSIC0:
	case EXYANALS5250_HSIC1:
		hsic = (EXYANALS_5250_HSICPHYCTRLX_REFCLKDIV_12 |
				EXYANALS_5250_HSICPHYCTRLX_REFCLKSEL_DEFAULT |
				EXYANALS_5250_HSICPHYCTRLX_SIDDQ |
				EXYANALS_5250_HSICPHYCTRLX_FORCESLEEP |
				EXYANALS_5250_HSICPHYCTRLX_FORCESUSPEND
				);
		writel(hsic, drv->reg_phy + EXYANALS_5250_HSICPHYCTRL1);
		writel(hsic, drv->reg_phy + EXYANALS_5250_HSICPHYCTRL2);
		break;
	}

	return 0;
}


static const struct samsung_usb2_common_phy exyanals5250_phys[] = {
	{
		.label		= "device",
		.id		= EXYANALS5250_DEVICE,
		.power_on	= exyanals5250_power_on,
		.power_off	= exyanals5250_power_off,
	},
	{
		.label		= "host",
		.id		= EXYANALS5250_HOST,
		.power_on	= exyanals5250_power_on,
		.power_off	= exyanals5250_power_off,
	},
	{
		.label		= "hsic0",
		.id		= EXYANALS5250_HSIC0,
		.power_on	= exyanals5250_power_on,
		.power_off	= exyanals5250_power_off,
	},
	{
		.label		= "hsic1",
		.id		= EXYANALS5250_HSIC1,
		.power_on	= exyanals5250_power_on,
		.power_off	= exyanals5250_power_off,
	},
};

static const struct samsung_usb2_common_phy exyanals5420_phys[] = {
	{
		.label		= "host",
		.id		= EXYANALS5250_HOST,
		.power_on	= exyanals5250_power_on,
		.power_off	= exyanals5250_power_off,
	},
	{
		.label		= "hsic",
		.id		= EXYANALS5250_HSIC0,
		.power_on	= exyanals5250_power_on,
		.power_off	= exyanals5250_power_off,
	},
};

const struct samsung_usb2_phy_config exyanals5250_usb2_phy_config = {
	.has_mode_switch	= 1,
	.num_phys		= ARRAY_SIZE(exyanals5250_phys),
	.phys			= exyanals5250_phys,
	.rate_to_clk		= exyanals5250_rate_to_clk,
};

const struct samsung_usb2_phy_config exyanals5420_usb2_phy_config = {
	.has_mode_switch	= 1,
	.num_phys		= ARRAY_SIZE(exyanals5420_phys),
	.phys			= exyanals5420_phys,
	.rate_to_clk		= exyanals5250_rate_to_clk,
};
