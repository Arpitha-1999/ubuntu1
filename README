MDB Linux Kernel Debugger

MDB (Merkey's Kernel Debugger) was written in 1998 and was one of the 
earliest debuggers on Linux. It was originally developed for Linux 
kernel file system development on the 2.2 series Linux kernels to be 
used as a loadable module.

MDB supports a lot of features and capabilities and enhances the range 
of tools for debugging kernel applications on Linux. If MDB is useful 
to you, please feel free to contribute any changes or enhancements back. 
MDB is fast, loads as a module, and supports complex conditional breakpoints 
and disassembly on the fly, and is extremely useful for debugging in the 
field.

Hardware Required: x86-64 or ia-32 system with Standard Keyboard or remote 
serial port. USB Keyboard not supported.

Installation

There are several options for installing MDB on your linux systems. You can 
download or clone the entire repository from git, you can download a simple 
patch or diff and patch your kernel (diff is easiest), or you can download 
a tar.gz file of all the current source code for each branch as a completely 
integrated kernel source tree. The simplest and fastest method is to 
download a diff and patch and build your kernel.

Download the diff which matches your particular linux version from 
http://jeffmerkey.github.io/linux, then apply the patch from your linux build 
directory. To download the diff and convert it into a patch file, click on 
the link for your kernel version for your system, then the patch text will 
display in your browser window, use your mouse to right click, then save as 
and save the patch into any filename you wish. It does not matter what 
filename you save the file under, you can choose any filename you wish, so 
long as it matches the filename you specify when you run the patch utility. 
To patch the kernel, from the linux build directory, type:

<<<<<<< HEAD
(linux build directory) patch -p1 < filename.diff
=======
 - If you install the full sources, put the kernel tarball in a
   directory where you have permissions (e.g. your home directory) and
   unpack it:
>>>>>>> 82b666eee71618b7ca812ee529af116582617dec

then type

make oldconfig

make bzImage modules modules_install install

You can also type "make menuconfig" to manually adjust kernel settings for 
your debugger under the section "Kernel Hacking". After the kernel rebuilds, 
reboot your system to the new kernel and you can load MDB as a module.

MDB Build Options

These are the following build options for enabling and configuring MDB to run 
on your linux kernel.

CONFIG_MDB

Kernel Debugger for Linux written to be used as a loadable module. 
'echo a > /proc/sysrq-trigger' will activate the debugger from the text 
based Linux Console, and the 'a' character (alt-printscreen/sysrq + 'a') 
with MAGIC_SYSRQ enabled to enter the debugger. X Windows is not supported. 
This debugger is minimal and text based. Excellent help can be obtained 
from the debugger by typing "Help Help" or "help" from the debugger command 
console. If you compiled MDB as a module you may need to load the debugger 
with the 'modprobe mdb' before you can access the debugger from the Linux 
Console. To enable the MAGIC-SYSRQ key type 
'echo 1 > /proc/sys/kernel/sysrq'. Use 'modinfo mdb' to display params 
for setting a serial port address for remote operations over serial link.

CONFIG_MDB_CONSOLE_REDIRECTION

Reset any Console Redirection to default system settings (0) when the MDB 
debugger is active. The Debugger will restore the redirection to the custom 
settings when the debugger is exited. This feature is useful on systems 
which by default redirect printk output and the screen debugger output to 
a log file or system device, which can prevent the debugger screen from 
being visible. Enabling this feature does not affect or disable remote 
operations via serial port. It is recommended to enable this feature by 
default to prevent the system console from being redirected during debugging.

CONFIG_MDB_DIRECT_MODE

Disable the default hardware breakpoint facility in Linux and allow MDB to 
control the debugger registers directly. This feature will disable KGBD, 
KDB-KGDB, and Ptrace but will still allow the userspace GDB debugger to 
function concurrently with MDB. Use this option if you want to disable 
other kernel debugging facilities other than mdb. Not recommended unless 
you really know what you are doing.

Loading MDB

To load MDB as a module, type:

modprobe mdb

To enter the debugger type:

echo a > /proc/sysrq-trigger

The debugger has excellent online help, just type 'h' or 'help' from the 
debugger console for a list of commands. For help with a specific command, 
just type 'help (command)' where (command) is the command you need help with.

Using MDB over a serial port

<<<<<<< HEAD
MDB is designed to be used from the local system console via keyboard, but 
can also be operated over a serial port and has very basic serial support. 
To set the serial port address, simply write the serial port address you
wish to use into the MDB module parameter mdb_serial_port located at 
sys/module/mdb/parameters/mdb_serial_port after you have loaded the MDB 
module.
=======
   When compiling the kernel, all output files will per default be
   stored together with the kernel source code.
   Using the option "make O=output/dir" allows you to specify an alternate
   place for the output files (including .config).
   Example:
>>>>>>> 82b666eee71618b7ca812ee529af116582617dec

cat /sys/module/mdb/parameters/mdb_serial_port

will display the current settings for the serial port. Default is "0".

echo 0x3f8 > /sys/module/mdb/parameters/mdb_serial_port

will set the serial port address to COM1 (ttyS0) which is port address 0x3f8.

To display other serial port address options most commonly used, type modinfo 
mdb. MDB expects the serial port address as a numerical value, so don't try 
to enter "ttyXX", use a numerical serial port address.

[root@localhost ~]# modinfo mdb
filename: /lib/modules/4.3.0+/kernel/arch/x86/kernel/debug/mdb/mdb.ko
license: GPL
description: Minimal Kernel Debugger
srcversion: C1CAC573BB00F3C65D21F7C
depends:
intree: Y
vermagic: 4.3.0+ SMP mod_unload modversions
parm: mdb_serial_port:MDB serial port address. 
i.e. 0x3f8(ttyS0), 0x2f8(ttyS1), 0x3e8(ttyS2), 0x2e8(ttyS3) (uint)
[root@localhost ~]#

Disabling KDB/KGDB

You need to check whether or not another kernel debugger is active on the 
system, and if so, disable it. Both the KGDB and KDB debuggers are available 
as default build options on Linux. Only one debugger can be running at a time 
on the system to function properly. Don't try to run MDB if KDB or KGDB are 
active, disable them first. If MDB is compiled as a module, during module 
loading MDB will attempt to disable KGDB/KDB if it detects either is active. 
You may see something like this in your /var/log/messages file after the 
module loads which indicates it detected and disabled KGDB or KDB:

localhost kernel: KGDB: Registered I/O driver kgdboc
localhost kernel: MDB: kgdb currently set to [kdb], attempting to disable.
localhost kernel: KGDB: Unregistered I/O driver kgdboc, debugger disabled
localhost kernel: MDB: kgdb/kdb set to disabled. MDB is enabled.

By default, MDB will always compile as a module unless you select it to 
compile directly into the kernel. If MDB is compiled in the kernel directly, 
you may need to check whether KGDB/KDB have been enabled before activating 
the MDB debugger.

<<<<<<< HEAD
To check whether kdb or kgdb are running on your system, type:

cat /sys/module/kgdboc/parameters/kgdboc
=======
     "make xconfig"     Qt based configuration tool.

     "make gconfig"     GTK+ based configuration tool.
>>>>>>> 82b666eee71618b7ca812ee529af116582617dec

if the text string "kdb", "kbd", or "tty"(some numbers) show up disable this 
interface by typing:

echo "" > /sys/module/kgdboc/parameters/kgdboc

which will disable kgdb and kdb and allow MDB to function correctly.

Using Git to pull remote MDB Branches

You can also use git to pull any of the debugger branches into your local git 
clone of the default linux and linux-stable git trees from www.kernel.org and 
build MDB directly from your tree as each branch corresponds to a particular 
kernel build and revision. To pull a remote branch from your local repository 
type:

git remote add mdb https://github.com/jeffmerkey/linux.git

git fetch mdb mdb-(branch version) i.e. git fetch mdb mdb-v4.3

make certain you create a local branch to merge to

git checkout (kernel version) i.e. git checkout v4.3

git branch (mdb branch) i.e. git branch mdb-v4.3

git checkout (mdb branch) i.e. git checkout mdb-v4.3

then if you wish to commit those changes, type:

git merge mdb/(branch version) i.e. git merge mdb/mdb-v4.3

you can also just pull directly and skip the fetch/merge steps just make 
certain you have created and switched to a local branch to commit your 
changes into.

git pull mdb mdb-(branch version) i.e. git pull mdb mdb-v4.3

After you have merged your changes into your local branch, switch to your 
local linux build directory then you can build your kernel by typing:

make oldconfig

make bzImage modules modules_install install

then follow the instructions above for loading MDB from the linux command 
line.

Support or Contact
Need to report a bug or issue with the MDB Linux Kernel Debugger? Please 
post it to Issues.

Having trouble with Pages? Check out Github's documentation or contact Github 
support and we'll help you sort it out.

<<<<<<< HEAD
Attribution
=======
COMPILING the kernel:

 - Make sure you have at least gcc 3.2 available.
   For more information, refer to Documentation/Changes.

   Please note that you can still run a.out user programs with this kernel.

 - Do a "make" to create a compressed kernel image. It is also
   possible to do "make install" if you have lilo installed to suit the
   kernel makefiles, but you may want to check your particular lilo setup first.

   To do the actual install, you have to be root, but none of the normal
   build should require that. Don't take the name of root in vain.

 - If you configured any of the parts of the kernel as `modules', you
   will also have to do "make modules_install".

 - Verbose kernel compile/build output:

   Normally, the kernel build system runs in a fairly quiet mode (but not
   totally silent).  However, sometimes you or other kernel developers need
   to see compile, link, or other commands exactly as they are executed.
   For this, use "verbose" build mode.  This is done by passing
   "V=1" to the "make" command, e.g.

     make V=1 all

   To have the build system also tell the reason for the rebuild of each
   target, use "V=2".  The default is "V=0".

 - Keep a backup kernel handy in case something goes wrong.  This is 
   especially true for the development releases, since each new release
   contains new code which has not been debugged.  Make sure you keep a
   backup of the modules corresponding to that kernel, as well.  If you
   are installing a new kernel with the same version number as your
   working kernel, make a backup of your modules directory before you
   do a "make modules_install".

   Alternatively, before compiling, use the kernel config option
   "LOCALVERSION" to append a unique suffix to the regular kernel version.
   LOCALVERSION can be set in the "General Setup" menu.

 - In order to boot your new kernel, you'll need to copy the kernel
   image (e.g. .../linux/arch/i386/boot/bzImage after compilation)
   to the place where your regular bootable kernel is found. 

 - Booting a kernel directly from a floppy without the assistance of a
   bootloader such as LILO, is no longer supported.

   If you boot Linux from the hard drive, chances are you use LILO, which
   uses the kernel image as specified in the file /etc/lilo.conf.  The
   kernel image file is usually /vmlinuz, /boot/vmlinuz, /bzImage or
   /boot/bzImage.  To use the new kernel, save a copy of the old image
   and copy the new image over the old one.  Then, you MUST RERUN LILO
   to update the loading map! If you don't, you won't be able to boot
   the new kernel image.

   Reinstalling LILO is usually a matter of running /sbin/lilo. 
   You may wish to edit /etc/lilo.conf to specify an entry for your
   old kernel image (say, /vmlinux.old) in case the new one does not
   work.  See the LILO docs for more information. 

   After reinstalling LILO, you should be all set.  Shutdown the system,
   reboot, and enjoy!

   If you ever need to change the default root device, video mode,
   ramdisk size, etc.  in the kernel image, use the 'rdev' program (or
   alternatively the LILO boot options when appropriate).  No need to
   recompile the kernel to change these parameters. 

 - Reboot with the new kernel and enjoy. 

IF SOMETHING GOES WRONG:

 - If you have problems that seem to be due to kernel bugs, please check
   the file MAINTAINERS to see if there is a particular person associated
   with the part of the kernel that you are having trouble with. If there
   isn't anyone listed there, then the second best thing is to mail
   them to me (torvalds@linux-foundation.org), and possibly to any other
   relevant mailing-list or to the newsgroup.

 - In all bug-reports, *please* tell what kernel you are talking about,
   how to duplicate the problem, and what your setup is (use your common
   sense).  If the problem is new, tell me so, and if the problem is
   old, please try to tell me when you first noticed it.

 - If the bug results in a message like

     unable to handle kernel paging request at address C0000010
     Oops: 0002
     EIP:   0010:XXXXXXXX
     eax: xxxxxxxx   ebx: xxxxxxxx   ecx: xxxxxxxx   edx: xxxxxxxx
     esi: xxxxxxxx   edi: xxxxxxxx   ebp: xxxxxxxx
     ds: xxxx  es: xxxx  fs: xxxx  gs: xxxx
     Pid: xx, process nr: xx
     xx xx xx xx xx xx xx xx xx xx

   or similar kernel debugging information on your screen or in your
   system log, please duplicate it *exactly*.  The dump may look
   incomprehensible to you, but it does contain information that may
   help debugging the problem.  The text above the dump is also
   important: it tells something about why the kernel dumped code (in
   the above example, it's due to a bad kernel pointer). More information
   on making sense of the dump is in Documentation/oops-tracing.txt

 - If you compiled the kernel with CONFIG_KALLSYMS you can send the dump
   as is, otherwise you will have to use the "ksymoops" program to make
   sense of the dump (but compiling with CONFIG_KALLSYMS is usually preferred).
   This utility can be downloaded from
   ftp://ftp.<country>.kernel.org/pub/linux/utils/kernel/ksymoops/ .
   Alternatively, you can do the dump lookup by hand:

 - In debugging dumps like the above, it helps enormously if you can
   look up what the EIP value means.  The hex value as such doesn't help
   me or anybody else very much: it will depend on your particular
   kernel setup.  What you should do is take the hex value from the EIP
   line (ignore the "0010:"), and look it up in the kernel namelist to
   see which kernel function contains the offending address.

   To find out the kernel function name, you'll need to find the system
   binary associated with the kernel that exhibited the symptom.  This is
   the file 'linux/vmlinux'.  To extract the namelist and match it against
   the EIP from the kernel crash, do:

     nm vmlinux | sort | less

   This will give you a list of kernel addresses sorted in ascending
   order, from which it is simple to find the function that contains the
   offending address.  Note that the address given by the kernel
   debugging messages will not necessarily match exactly with the
   function addresses (in fact, that is very unlikely), so you can't
   just 'grep' the list: the list will, however, give you the starting
   point of each kernel function, so by looking for the function that
   has a starting address lower than the one you are searching for but
   is followed by a function with a higher address you will find the one
   you want.  In fact, it may be a good idea to include a bit of
   "context" in your problem report, giving a few lines around the
   interesting one. 

   If you for some reason cannot do the above (you have a pre-compiled
   kernel image or similar), telling me as much about your setup as
   possible will help.  Please read the REPORTING-BUGS document for details.

 - Alternatively, you can use gdb on a running kernel. (read-only; i.e. you
   cannot change values or set break points.) To do this, first compile the
   kernel with -g; edit arch/i386/Makefile appropriately, then do a "make
   clean". You'll also need to enable CONFIG_PROC_FS (via "make config").

   After you've rebooted with the new kernel, do "gdb vmlinux /proc/kcore".
   You can now use all the usual gdb commands. The command to look up the
   point where your system crashed is "l *0xXXXXXXXX". (Replace the XXXes
   with the EIP value.)

   gdb'ing a non-running kernel currently fails because gdb (wrongly)
   disregards the starting offset for which the kernel is compiled.
>>>>>>> 82b666eee71618b7ca812ee529af116582617dec

Linux(r) is a registered trademark of Linus Torvalds in the US and other countries.
