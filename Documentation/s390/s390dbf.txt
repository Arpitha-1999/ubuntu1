S390 De Feature
==================

files: arch/s390/kernel/de.c
       arch/s390/include/asm/de.h

Description:
------------
The goal of this feature is to provide a kernel de logging API 
where log records can be stored efficiently in memory, where each component 
(e.g. device drivers) can have one separate de log.
One purpose of this is to inspect the de logs after a production system crash
in order to analyze the reason for the crash.
If the system still runs but only a subcomponent which uses dbf fails,
it is possible to look at the de logs on a live system via the Linux
defs filesystem.
The de feature may also very useful for kernel and driver development.

Design:
-------
Kernel components (e.g. device drivers) can register themselves at the de 
feature with the function call de_register(). This function initializes a 
de log for the caller. For each de log exists a number of de areas 
where exactly one is active at one time.  Each de area consists of contiguous
pages in memory. In the de areas there are stored de entries (log records)
which are written by event- and exception-calls. 

An event-call writes the specified de entry to the active de
area and updates the log pointer for the active area. If the end 
of the active de area is reached, a wrap around is done (ring buffer) 
and the next de entry will be written at the beginning of the active 
de area.

An exception-call writes the specified de entry to the log and
switches to the next de area. This is done in order to be sure
that the records which describe the origin of the exception are not
overwritten when a wrap around for the current area occurs.

The de areas themselves are also ordered in form of a ring buffer.
When an exception is thrown in the last de area, the following de 
entries are then written again in the very first area.

There are three versions for the event- and exception-calls: One for
logging raw data, one for text and one for numbers.

Each de entry contains the following data:

- Timestamp
- Cpu-Number of calling task
- Level of de entry (0...6)
- Return Address to caller
- Flag, if entry is an exception or not

The de logs can be inspected in a live system through entries in
the defs-filesystem. Under the toplevel directory "s390dbf" there is
a directory for each registered component, which is named like the
corresponding component. The defs normally should be mounted to
/sys/kernel/de therefore the de feature can be accessed under
/sys/kernel/de/s390dbf.

The content of the directories are files which represent different views
to the de log. Each component can decide which views should be
used through registering them with the function de_register_view().
Predefined views for hex/ascii, sprintf and raw binary data are provided.
It is also possible to define other views. The content of
a view can be inspected simply by reading the corresponding defs file.

All de logs have an actual de level (range from 0 to 6).
The default level is 3. Event and Exception functions have a 'level'
parameter. Only de entries with a level that is lower or equal
than the actual level are written to the log. This means, when
writing events, high priority log entries should have a low level
value whereas low priority entries should have a high one.
The actual de level can be changed with the help of the defs-filesystem
through writing a number string "x" to the 'level' defs file which is
provided for every de log. Deging can be switched off completely
by using "-" on the 'level' defs file.

Example:

> echo "-" > /sys/kernel/de/s390dbf/dasd/level

It is also possible to deactivate the de feature globally for every
de log. You can change the behavior using  2 sysctl parameters in
/proc/sys/s390dbf:
There are currently 2 possible triggers, which stop the de feature
globally. The first possibility is to use the "de_active" sysctl. If
set to 1 the de feature is running. If "de_active" is set to 0 the
de feature is turned off.
The second trigger which stops the de feature is a kernel oops.
That prevents the de feature from overwriting de information that
happened before the oops. After an oops you can reactivate the de feature
by piping 1 to /proc/sys/s390dbf/de_active. Nevertheless, its not
suggested to use an oopsed kernel in a production environment.
If you want to disallow the deactivation of the de feature, you can use
the "de_stoppable" sysctl. If you set "de_stoppable" to 0 the de
feature cannot be stopped. If the de feature is already stopped, it
will stay deactivated.

Kernel Interfaces:
------------------

----------------------------------------------------------------------------
de_info_t *de_register(char *name, int pages, int nr_areas,
                             int buf_size);

Parameter:    name:        Name of de log (e.g. used for defs entry)
              pages:       number of pages, which will be allocated per area
              nr_areas:    number of de areas
              buf_size:    size of data area in each de entry

Return Value: Handle for generated de area   
              NULL if register failed 

Description:  Allocates memory for a de log     
              Must not be called within an interrupt handler 

----------------------------------------------------------------------------
de_info_t *de_register_mode(char *name, int pages, int nr_areas,
				  int buf_size, mode_t mode, uid_t uid,
				  gid_t gid);

Parameter:    name:	   Name of de log (e.g. used for defs entry)
	      pages:	   Number of pages, which will be allocated per area
	      nr_areas:    Number of de areas
	      buf_size:    Size of data area in each de entry
	      mode:	   File mode for defs files. E.g. S_IRWXUGO
	      uid:	   User ID for defs files. Currently only 0 is
			   supported.
	      gid:	   Group ID for defs files. Currently only 0 is
			   supported.

Return Value: Handle for generated de area
	      NULL if register failed

Description:  Allocates memory for a de log
	      Must not be called within an interrupt handler

---------------------------------------------------------------------------
void de_unregister (de_info_t * id);

Parameter:     id:   handle for de log  

Return Value:  none 

Description:   frees memory for a de log and removes all registered de
	       views.
               Must not be called within an interrupt handler 

---------------------------------------------------------------------------
void de_set_level (de_info_t * id, int new_level);

Parameter:     id:        handle for de log  
               new_level: new de level 

Return Value:  none 

Description:   Sets new actual de level if new_level is valid. 

---------------------------------------------------------------------------
bool de_level_enabled (de_info_t * id, int level);

Parameter:    id:	  handle for de log
	      level:	  de level

Return Value: True if level is less or equal to the current de level.

Description:  Returns true if de events for the specified level would be
	      logged. Otherwise returns false.
---------------------------------------------------------------------------
void de_stop_all(void);

Parameter:     none

Return Value:  none

Description:   stops the de feature if stopping is allowed. Currently
               used in case of a kernel oops.

---------------------------------------------------------------------------
de_entry_t* de_event (de_info_t* id, int level, void* data, 
                            int length);

Parameter:     id:     handle for de log  
               level:  de level           
               data:   pointer to data for de entry  
               length: length of data in bytes       

Return Value:  Address of written de entry 

Description:   writes de entry to active de area (if level <= actual 
               de level)    

---------------------------------------------------------------------------
de_entry_t* de_int_event (de_info_t * id, int level, 
                                unsigned int data);
de_entry_t* de_long_event(de_info_t * id, int level,
                                unsigned long data);

Parameter:     id:     handle for de log  
               level:  de level           
               data:   integer value for de entry           

Return Value:  Address of written de entry 

Description:   writes de entry to active de area (if level <= actual 
               de level)    

---------------------------------------------------------------------------
de_entry_t* de_text_event (de_info_t * id, int level, 
                                 const char* data);

Parameter:     id:     handle for de log  
               level:  de level           
               data:   string for de entry  

Return Value:  Address of written de entry 

Description:   writes de entry in ascii format to active de area 
               (if level <= actual de level)     

---------------------------------------------------------------------------
de_entry_t* de_sprintf_event (de_info_t * id, int level, 
                                    char* string,...);

Parameter:     id:    handle for de log 
               level: de level
               string: format string for de entry 
               ...: varargs used as in sprintf()

Return Value:  Address of written de entry

Description:   writes de entry with format string and varargs (longs) to 
               active de area (if level $<=$ actual de level). 
               floats and long long datatypes cannot be used as varargs.

---------------------------------------------------------------------------

de_entry_t* de_exception (de_info_t* id, int level, void* data, 
                                int length);

Parameter:     id:     handle for de log  
               level:  de level           
               data:   pointer to data for de entry  
               length: length of data in bytes       

Return Value:  Address of written de entry 

Description:   writes de entry to active de area (if level <= actual 
               de level) and switches to next de area  

---------------------------------------------------------------------------
de_entry_t* de_int_exception (de_info_t * id, int level, 
                                    unsigned int data);
de_entry_t* de_long_exception(de_info_t * id, int level,
                                    unsigned long data);

Parameter:     id:     handle for de log  
               level:  de level           
               data:   integer value for de entry           

Return Value:  Address of written de entry 

Description:   writes de entry to active de area (if level <= actual 
               de level) and switches to next de area  

---------------------------------------------------------------------------
de_entry_t* de_text_exception (de_info_t * id, int level, 
                                     const char* data);

Parameter:     id:     handle for de log  
               level:  de level           
               data:   string for de entry  

Return Value:  Address of written de entry 

Description:   writes de entry in ascii format to active de area 
               (if level <= actual de level) and switches to next de 
               area  

---------------------------------------------------------------------------
de_entry_t* de_sprintf_exception (de_info_t * id, int level,
                                        char* string,...);

Parameter:     id:    handle for de log  
               level: de level  
               string: format string for de entry  
               ...: varargs used as in sprintf()

Return Value:  Address of written de entry 

Description:   writes de entry with format string and varargs (longs) to 
               active de area (if level $<=$ actual de level) and
               switches to next de area. 
               floats and long long datatypes cannot be used as varargs.

---------------------------------------------------------------------------

int de_register_view (de_info_t * id, struct de_view *view);

Parameter:     id:    handle for de log  
               view:  pointer to de view struct 

Return Value:  0  : ok 
               < 0: Error 

Description:   registers new de view and creates defs dir entry

---------------------------------------------------------------------------
int de_unregister_view (de_info_t * id, struct de_view *view); 

Parameter:     id:    handle for de log  
               view:  pointer to de view struct 

Return Value:  0  : ok 
               < 0: Error 

Description:   unregisters de view and removes defs dir entry



Predefined views:
-----------------

extern struct de_view de_hex_ascii_view;
extern struct de_view de_raw_view;
extern struct de_view de_sprintf_view;

Examples
--------

/*
 * hex_ascii- + raw-view Example
 */

#include <linux/init.h>
#include <asm/de.h>

static de_info_t* de_info;

static int init(void)
{
    /* register 4 de areas with one page each and 4 byte data field */

    de_info = de_register ("test", 1, 4, 4 );
    de_register_view(de_info,&de_hex_ascii_view);
    de_register_view(de_info,&de_raw_view);

    de_text_event(de_info, 4 , "one ");
    de_int_exception(de_info, 4, 4711);
    de_event(de_info, 3, &de_info, 4);

    return 0;
}

static void cleanup(void)
{
    de_unregister (de_info);
}

module_init(init);
module_exit(cleanup);

---------------------------------------------------------------------------

/*
 * sprintf-view Example
 */

#include <linux/init.h>
#include <asm/de.h>

static de_info_t* de_info;

static int init(void)
{
    /* register 4 de areas with one page each and data field for */
    /* format string pointer + 2 varargs (= 3 * sizeof(long))       */

    de_info = de_register ("test", 1, 4, sizeof(long) * 3);
    de_register_view(de_info,&de_sprintf_view);

    de_sprintf_event(de_info, 2 , "first event in %s:%i\n",__FILE__,__LINE__);
    de_sprintf_exception(de_info, 1, "pointer to de info: %p\n",&de_info);

    return 0;
}

static void cleanup(void)
{
    de_unregister (de_info);
}

module_init(init);
module_exit(cleanup);



Defs Interface
----------------
Views to the de logs can be investigated through reading the corresponding 
defs-files:

Example:

> ls /sys/kernel/de/s390dbf/dasd
flush  hex_ascii  level pages raw
> cat /sys/kernel/de/s390dbf/dasd/hex_ascii | sort -k2,2 -s
00 00974733272:680099 2 - 02 0006ad7e  07 ea 4a 90 | ....
00 00974733272:682210 2 - 02 0006ade6  46 52 45 45 | FREE
00 00974733272:682213 2 - 02 0006adf6  07 ea 4a 90 | ....
00 00974733272:682281 1 * 02 0006ab08  41 4c 4c 43 | EXCP 
01 00974733272:682284 2 - 02 0006ab16  45 43 4b 44 | ECKD
01 00974733272:682287 2 - 02 0006ab28  00 00 00 04 | ....
01 00974733272:682289 2 - 02 0006ab3e  00 00 00 20 | ... 
01 00974733272:682297 2 - 02 0006ad7e  07 ea 4a 90 | ....
01 00974733272:684384 2 - 00 0006ade6  46 52 45 45 | FREE
01 00974733272:684388 2 - 00 0006adf6  07 ea 4a 90 | ....

See section about predefined views for explanation of the above output!

Changing the de level
------------------------

Example:


> cat /sys/kernel/de/s390dbf/dasd/level
3
> echo "5" > /sys/kernel/de/s390dbf/dasd/level
> cat /sys/kernel/de/s390dbf/dasd/level
5

Flushing de areas
--------------------
De areas can be flushed with piping the number of the desired
area (0...n) to the defs file "flush". When using "-" all de areas
are flushed.

Examples:

1. Flush de area 0:
> echo "0" > /sys/kernel/de/s390dbf/dasd/flush

2. Flush all de areas:
> echo "-" > /sys/kernel/de/s390dbf/dasd/flush

Changing the size of de areas
------------------------------------
It is possible the change the size of de areas through piping
the number of pages to the defs file "pages". The resize request will
also flush the de areas.

Example:

Define 4 pages for the de areas of de feature "dasd":
> echo "4" > /sys/kernel/de/s390dbf/dasd/pages

Stooping the de feature
--------------------------
Example:

1. Check if stopping is allowed
> cat /proc/sys/s390dbf/de_stoppable
2. Stop de feature
> echo 0 > /proc/sys/s390dbf/de_active

lcrash Interface
----------------
It is planned that the dump analysis tool lcrash gets an additional command
's390dbf' to display all the de logs. With this tool it will be possible 
to investigate the de logs on a live system and with a memory dump after 
a system crash.

Investigating raw memory
------------------------
One last possibility to investigate the de logs at a live
system and after a system crash is to look at the raw memory
under VM or at the Service Element.
It is possible to find the anker of the de-logs through
the 'de_area_first' symbol in the System map. Then one has
to follow the correct pointers of the data-structures defined
in de.h and find the de-areas in memory.
Normally modules which use the de feature will also have
a global variable with the pointer to the de-logs. Following
this pointer it will also be possible to find the de logs in
memory.

For this method it is recommended to use '16 * x + 4' byte (x = 0..n)
for the length of the data field in de_register() in
order to see the de entries well formatted.


Predefined Views
----------------

There are three predefined views: hex_ascii, raw and sprintf. 
The hex_ascii view shows the data field in hex and ascii representation 
(e.g. '45 43 4b 44 | ECKD'). 
The raw view returns a bytestream as the de areas are stored in memory.

The sprintf view formats the de entries in the same way as the sprintf
function would do. The sprintf event/exception functions write to the
de entry a pointer to the format string (size = sizeof(long)) 
and for each vararg a long value. So e.g. for a de entry with a format 
string plus two varargs one would need to allocate a (3 * sizeof(long)) 
byte data area in the de_register() function.

IMPORTANT: Using "%s" in sprintf event functions is dangerous. You can only
use "%s" in the sprintf event functions, if the memory for the passed string is
available as long as the de feature exists. The reason behind this is that
due to performance considerations only a pointer to the string is stored in
the de feature. If you log a string that is freed afterwards, you will get
an OOPS when inspecting the de feature, because then the de feature will
access the already freed memory.

NOTE: If using the sprintf view do NOT use other event/exception functions
than the sprintf-event and -exception functions.

The format of the hex_ascii and sprintf view is as follows:
- Number of area
- Timestamp (formatted as seconds and microseconds since 00:00:00 Coordinated 
  Universal Time (UTC), January 1, 1970)
- level of de entry
- Exception flag (* = Exception)
- Cpu-Number of calling task
- Return Address to caller
- data field

The format of the raw view is:
- Header as described in de.h
- datafield 

A typical line of the hex_ascii view will look like the following (first line 
is only for explanation and will not be displayed when 'cating' the view):

area  time           level exception cpu caller    data (hex + ascii)
--------------------------------------------------------------------------
00    00964419409:440690 1 -         00  88023fe   


Defining views
--------------

Views are specified with the 'de_view' structure. There are defined
callback functions which are used for reading and writing the defs files:

struct de_view {
        char name[DE_MAX_PROCF_LEN];  
        de_prolog_proc_t* prolog_proc; 
        de_header_proc_t* header_proc;
        de_format_proc_t* format_proc;
        de_input_proc_t*  input_proc;
	void*                private_data;
};

where

typedef int (de_header_proc_t) (de_info_t* id,
                                   struct de_view* view,
                                   int area,
                                   de_entry_t* entry,
                                   char* out_buf);

typedef int (de_format_proc_t) (de_info_t* id,
                                   struct de_view* view, char* out_buf,
                                   const char* in_buf);
typedef int (de_prolog_proc_t) (de_info_t* id,
                                   struct de_view* view,
                                   char* out_buf);
typedef int (de_input_proc_t) (de_info_t* id,
                                  struct de_view* view,
                                  struct file* file, const char* user_buf,
                                  size_t in_buf_size, loff_t* offset);


The "private_data" member can be used as pointer to view specific data.
It is not used by the de feature itself.

The output when reading a defs file is structured like this:

"prolog_proc output"

"header_proc output 1"  "format_proc output 1"
"header_proc output 2"  "format_proc output 2"
"header_proc output 3"  "format_proc output 3"
...

When a view is read from the defs, the De Feature calls the
'prolog_proc' once for writing the prolog.
Then 'header_proc' and 'format_proc' are called for each 
existing de entry.

The input_proc can be used to implement functionality when it is written to 
the view (e.g. like with 'echo "0" > /sys/kernel/de/s390dbf/dasd/level).

For header_proc there can be used the default function
de_dflt_header_fn() which is defined in de.h.
and which produces the same header output as the predefined views.
E.g:
00 00964419409:440761 2 - 00 88023ec

In order to see how to use the callback functions check the implementation
of the default views!

Example

#include <asm/de.h>

#define UNKNOWNSTR "data: %08x"

const char* messages[] =
{"This error...........\n",
 "That error...........\n",
 "Problem..............\n",
 "Something went wrong.\n",
 "Everything ok........\n",
 NULL
};

static int de_test_format_fn(
   de_info_t * id, struct de_view *view, 
   char *out_buf, const char *in_buf
)
{
  int i, rc = 0;

  if(id->buf_size >= 4) {
     int msg_nr = *((int*)in_buf);
     if(msg_nr < sizeof(messages)/sizeof(char*) - 1)
        rc += sprintf(out_buf, "%s", messages[msg_nr]);	
     else
        rc += sprintf(out_buf, UNKNOWNSTR, msg_nr);
  }
 out:
   return rc;
}

struct de_view de_test_view = {
  "myview",                 /* name of view */
  NULL,                     /* no prolog */
  &de_dflt_header_fn,    /* default header for each entry */
  &de_test_format_fn,    /* our own format function */
  NULL,                     /* no input function */
  NULL                      /* no private data */
};

=====
test:
=====
de_info_t *de_info;
...
de_info = de_register ("test", 0, 4, 4 ));
de_register_view(de_info, &de_test_view);
for(i = 0; i < 10; i ++) de_int_event(de_info, 1, i);

> cat /sys/kernel/de/s390dbf/test/myview
00 00964419734:611402 1 - 00 88042ca   This error...........
00 00964419734:611405 1 - 00 88042ca   That error...........
00 00964419734:611408 1 - 00 88042ca   Problem..............
00 00964419734:611411 1 - 00 88042ca   Something went wrong.
00 00964419734:611414 1 - 00 88042ca   Everything ok........
00 00964419734:611417 1 - 00 88042ca   data: 00000005
00 00964419734:611419 1 - 00 88042ca   data: 00000006
00 00964419734:611422 1 - 00 88042ca   data: 00000007
00 00964419734:611425 1 - 00 88042ca   data: 00000008
00 00964419734:611428 1 - 00 88042ca   data: 00000009
