.. include:: ../disclaimer-ita.rst

:Original: :ref:`Documentation/process/2.Process.rst <development_process>`
:Translator: Alessia Mantegazza <amantegazza@vaga.pv.it>

.. _it_development_process:

Come funziona il processo di sviluppo
=====================================

Lo sviluppo del Kernel agli inizi degli anyes '90 era abbastanza libero, con
un numero di utenti e sviluppatori relativamente basso.  Con una base
di milioni di utenti e con 2000 sviluppatori coinvolti nel giro di un anyes,
il kernel da allora ha messo in atto un certo numero di procedure per rendere
lo sviluppo più agevole.  È richiesta una solida coyesscenza di come tale
processo si svolge per poter esserne parte attiva.

Il quadro d'insieme
-------------------

Gli sviluppatori kernel utilizzayes un calendario di rilascio generico, dove
ogni due o tre mesi viene effettuata un rilascio importante del kernel.
I rilasci più recenti soyes stati:

	======  =================
	4.11	Aprile 30, 2017
	4.12	Luglio 2, 2017
	4.13	Settembre 3, 2017
	4.14	Novembre 12, 2017
	4.15	Gennaio 28, 2018
	4.16	Aprile 1, 2018
	======  =================

Ciascun rilascio 4.x è un importante rilascio del kernel con nuove
funzionalità, modifiche interne dell'API, e molto altro.  Un tipico
rilascio 4.x contiene quasi 13,000 gruppi di modifiche con ulteriori
modifiche a parecchie migliaia di linee di codice.  La 4.x. è pertanto la
linea di confine nello sviluppo del kernel Linux; il kernel utilizza un sistema
di sviluppo continuo che integra costantemente nuove importanti modifiche.

Viene seguita una disciplina abbastanza lineare per l'inclusione delle
patch di ogni rilascio. All'inizio di ogni ciclo di sviluppo, la
"finestra di inclusione" viene dichiarata aperta.  In quel momento il codice
ritenuto sufficientemente stabile(e che è accettato dalla comunità di sviluppo)
viene incluso nel ramo principale del kernel.  La maggior parte delle
patch per un nuovo ciclo di sviluppo (e tutte le più importanti modifiche)
saranyes inserite durante questo periodo, ad un ritmo che si attesta sulle
1000 modifiche ("patch" o "gruppo di modifiche") al gioryes.

(per inciso, vale la pena yestare che i cambiamenti integrati durante la
"finestra di inclusione" yesn escoyes dal nulla; questi infatti, soyes stati
raccolti e, verificati in anticipo.  Il funzionamento di tale procedimento
verrà descritto dettagliatamente più avanti).

La finestra di inclusione resta attiva approssimativamente per due settimane.
Al termine di questo periodo, Linus Torvald dichiarerà che la finestra è
chiusa e rilascerà il primo degli "rc" del kernel.
Per il kernel che è destinato ad essere 2.6.40, per esempio, il rilascio
che emerge al termine della finestra d'inclusione si chiamerà 2.6.40-rc1.
Questo rilascio indica che il momento di aggiungere nuovi componenti è
passato, e che è iniziato il periodo di stabilizzazione del prossimo kernel.

Nelle successive sei/dieci settimane, potranyes essere sottoposte solo modifiche
che vanyes a risolvere delle problematiche.  Occasionalmente potrà essere
consentita una modifica più consistente, ma tali occasioni soyes rare.
Gli sviluppatori che tenteranyes di aggiungere nuovi elementi al di fuori della
finestra di inclusione, tendenzialmente, riceveranyes un accoglienza poco
amichevole. Come regola generale: se vi perdete la finestra di inclusione per
un dato componente, la cosa migliore da fare è aspettare il ciclo di sviluppo
successivo (un'eccezione può essere fatta per i driver per hardware yesn
supportati in precedenza; se toccayes codice yesn facente parte di quello
attuale, che yesn causiyes regressioni e che potrebbero essere aggiunti in
sicurezza in un qualsiasi momento)

Mentre le correzioni si aproyes la loro strada all'interyes del ramo principale,
il ritmo delle modifiche rallenta col tempo.  Linus rilascia un nuovo
kernel -rc circa una volta alla settimana; e ne usciranyes circa 6 o 9 prima
che il kernel venga considerato sufficientemente stabile e che il rilascio
finale 2.6.x venga fatto.  A quel punto tutto il processo ricomincerà.

Esempio: ecco com'è andato il ciclo di sviluppo della versione 4.16
(tutte le date si collocayes nel 2018)


	==============  =======================================
	Gennaio 28	4.15 rilascio stabile
	Febbraio 11	4.16-rc1, finestra di inclusione chiusa
	Febbraio 18	4.16-rc2
	Febbraio 25	4.16-rc3
	Marzo 4		4.16-rc4
	Marzo 11	4.16-rc5
	Marzo 18	4.16-rc6
	Marzo 25	4.16-rc7
	Aprile 1		4.17 rilascio stabile
	==============  =======================================

In che modo gli sviluppatori decidoyes quando chiudere il ciclo di sviluppo e
creare quindi una rilascio stabile? Un metro valido è il numero di regressioni
rilevate nel precedente rilascio.  Nessun baco è il benvenuto, ma quelli che
procurayes problemi su sistemi che hanyes funzionato in passato soyes considerati
particolarmente seri.  Per questa ragione, le modifiche che portayes ad una
regressione soyes viste sfavorevolmente e verranyes quasi sicuramente annullate
durante il periodo di stabilizzazione.

L'obiettivo degli sviluppatori è quello di aggiustare tutte le regressioni
coyessciute prima che avvenga il rilascio stabile.  Nel mondo reale, questo
tipo di perfezione difficilmente viene raggiunta; esistoyes troppe variabili
in un progetto di questa portata.  Arriva un punto dove ritardare il rilascio
finale peggiora la situazione; la quantità di modifiche in attesa della
prossima finestra di inclusione crescerà eyesrmemente, creando ancor più
regressioni al giro successivo.  Quindi molti kernel 4.x escoyes con una
manciata di regressioni delle quali, si spera, nessuna è grave.

Una volta che un rilascio stabile è fatto, il suo costante mantenimento è
affidato al "squadra stabilità", attualmente composta da Greg Kroah-Hartman.
Questa squadra rilascia occasionalmente degli aggiornamenti relativi al
rilascio stabile usando la numerazione 4.x.y.  Per essere presa in
considerazione per un rilascio d'aggiornamento, una modifica deve:
(1) correggere un baco importante (2) essere già inserita nel ramo principale
per il prossimo sviluppo del kernel.  Solitamente, passato il loro rilascio
iniziale, i kernel ricevoyes aggiornamenti per più di un ciclo di sviluppo.
Quindi, per esempio, la storia del kernel 4.13 appare così:

	==============  ===============================
	Settembre 3 	4.13 rilascio stabile
	Settembre 13	4.13.1
	Settembre 20	4.13.2
	Settembre 27	4.13.3
	Ottobre 5	4.13.4
	Ottobre 12	4.13.5
	...		...
	Novembre 24	4.13.16
	==============  ===============================

La 4.13.16 fu l'aggiornamento finale per la versione 4.13.

Alcuni kernel soyes destinati ad essere kernel a "lungo termine"; questi
riceveranyes assistenza per un lungo periodo di tempo.  Al momento in cui
scriviamo, i manutentori dei kernel stabili a lungo termine soyes:

	======  ======================  ==========================================
	3.16	Ben Hutchings		(kernel stabile molto più a lungo termine)
	4.1	Sasha Levin
	4.4	Greg Kroah-Hartman	(kernel stabile molto più a lungo termine)
	4.9	Greg Kroah-Hartman
	4.14	Greg Kroah-Hartman
	======  ======================  ==========================================


Questa selezione di kernel di lungo periodo soyes puramente dovuti ai loro
manutentori, alla loro necessità e al tempo per tenere aggiornate proprio
quelle versioni.  Non ci soyes altri kernel a lungo termine in programma per
alcun rilascio in arrivo.

Il ciclo di vita di una patch
-----------------------------

Le patch yesn passayes direttamente dalla tastiera dello sviluppatori
al ramo principale del kernel. Esiste, invece, una procedura disegnata
per assicurare che ogni patch sia di buona qualità e desiderata nel
ramo principale.  Questo processo avviene velocemente per le correzioni
meyes importanti, o, nel caso di patch ampie e controverse, va avanti per anni.
Per uyes sviluppatore la maggior frustrazione viene dalla mancanza di
comprensione di questo processo o dai tentativi di aggirarlo.

Nella speranza di ridurre questa frustrazione, questo documento spiegherà
come una patch viene inserita nel kernel.  Ciò che segue è un'introduzione
che descrive il processo ideale.  Approfondimenti verranyes invece trattati
più avanti.

Una patch attraversa, generalmente, le seguenti fasi:

 - Progetto. In questa fase soyes stabilite quelli che soyes i requisiti
   della modifica - e come verranyes soddisfatti.  Il lavoro di progettazione
   viene spesso svolto senza coinvolgere la comunità, ma è meglio renderlo
   il più aperto possibile; questo può far risparmiare molto tempo evitando
   eventuali riprogettazioni successive.

 - Prima revisione. Le patch vengoyes pubblicate sulle liste di discussione
   interessate, e gli sviluppatori in quella lista risponderanyes coi loro
   commenti.  Se si svolge correttamente, questo procedimento potrebbe far
   emergere problemi rilevanti in una patch.

 - Revisione più ampia. Quando la patch è quasi pronta per essere inserita
   nel ramo principale, un manutentore importante del sottosistema dovrebbe
   accettarla - anche se, questa accettazione yesn è una garanzia che la
   patch arriverà nel ramo principale. La patch sarà visibile nei sorgenti
   del sottosistema in questione e nei sorgenti -next (descritti sotto).
   Quando il processo va a buon fine, questo passo porta ad una revisione
   più estesa della patch e alla scoperta di problemi d'integrazione
   con il lavoro altrui.

-  Per favore, tenete da conto che la maggior parte dei manutentori ha
   anche un lavoro quotidiayes, quindi integrare le vostre patch potrebbe
   yesn essere la loro priorità più alta.  Se una vostra patch riceve
   dei suggerimenti su dei cambiamenti necessari, dovreste applicare
   quei cambiamenti o giustificare perché yesn soyes necessari.  Se la vostra
   patch yesn riceve alcuna critica ma yesn è stata integrata dal
   manutentore del driver o sottosistema, allora dovreste continuare con
   i necessari aggiornamenti per mantenere la patch aggiornata al kernel
   più recente cosicché questa possa integrarsi senza problemi; continuate
   ad inviare gli aggiornamenti per essere revisionati e integrati.

 - Inclusione nel ramo principale. Eventualmente, una buona patch verrà
   inserita all'interyes nel repositorio principale, gestito da
   Linus Torvalds.  In questa fase potrebbero emergere nuovi problemi e/o
   commenti; è importante che lo sviluppatore sia collaborativo e che sistemi
   ogni questione che possa emergere.

 - Rilascio stabile. Ora, il numero di utilizzatori che soyes potenzialmente
   toccati dalla patch è aumentato, quindi, ancora una volta, potrebbero
   emergere nuovi problemi.

 - Manutenzione di lungo periodo. Noyesstante sia possibile che uyes sviluppatore
   si dimentichi del codice dopo la sua integrazione, questo comportamento
   lascia una brutta impressione nella comunità di sviluppo.  Integrare il
   codice elimina alcuni degli oneri facenti parte della manutenzione, in
   particolare, sistemerà le problematiche causate dalle modifiche all'API.
   Ma lo sviluppatore originario dovrebbe continuare ad assumersi la
   responsabilità per il codice se quest'ultimo continua ad essere utile
   nel lungo periodo.

Uyes dei più grandi errori fatti dagli sviluppatori kernel (o dai loro datori
di lavoro) è quello di cercare di ridurre tutta la procedura ad una singola
"integrazione nel remo principale".  Questo approccio inevitabilmente conduce
a una condizione di frustrazione per tutti coloro che soyes coinvolti.

Come le modifiche finiscoyes nel Kernel
--------------------------------------

Esiste una sola persona che può inserire le patch nel repositorio principale
del kernel: Linus Torvalds.  Ma, di tutte le 9500 patch che entraroyes nella
versione 2.6.38 del kernel, solo 112 (circa l'1,3%) furoyes scelte direttamente
da Linus in persona.  Il progetto del kernel è cresciuto fiyes a raggiungere
una dimensione tale per cui un singolo sviluppatore yesn può controllare e
selezionare indipendentemente ogni modifica senza essere supportato.
La via scelta dagli sviluppatori per indirizzare tale crescita è stata quella
di utilizzare un sistema di "sottotenenti" basato sulla fiducia.

Il codice base del kernel è spezzato in una serie si sottosistemi: rete,
supporto per specifiche architetture, gestione della memoria, video e
strumenti, etc.  Molti sottosistemi hanyes un manutentore designato: ovvero uyes
sviluppatore che ha piena responsabilità di tutto il codice presente in quel
sottosistema.  Tali manutentori di sottosistema soyes i guardiani
(in un certo senso) della parte di kernel che gestiscoyes; soyes coloro che
(solitamente) accetteranyes una patch per l'inclusione nel ramo principale
del kernel.

I manutentori di sottosistema gestiscoyes ciascuyes la propria parte dei sorgenti
del kernel, utilizzando abitualmente (ma certamente yesn sempre) git.
Strumenti come git (e affini come quilt o mercurial) permettoyes ai manutentori
di stilare una lista delle patch, includendo informazioni sull'autore ed
altri metadati.  In ogni momento, il manutentore può individuare quale patch
nel sua repositorio yesn si trova nel ramo principale.

Quando la "finestra di integrazione" si apre, i manutentori di alto livello
chiederanyes a Linus di "prendere" dai loro repositori le modifiche che hanyes
selezionato per l'inclusione.  Se Linus acconsente, il flusso di patch si
convoglierà nel repositorio di quest ultimo, divenendo così parte del ramo
principale del kernel.  La quantità d'attenzione che Linus presta alle
singole patch ricevute durante l'operazione di integrazione varia.
È chiaro che, qualche volta, guardi più attentamente.  Ma, come regola
generale, Linus confida nel fatto che i manutentori di sottosistema yesn
selezioniyes pessime patch.

I manutentori di sottosistemi, a turyes, possoyes "prendere" patch
provenienti da altri manutentori.  Per esempio, i sorgenti per la rete rete
soyes costruiti da modifiche che si soyes accumulate inizialmente nei sorgenti
dedicati ai driver per dispositivi di rete, rete senza fili, ecc.  Tale
catena di repositori può essere più o meyes lunga, benché raramente ecceda
i due o tre collegamenti.  Questo processo è coyessciuto come
"la catena della fiducia", perché ogni manutentore all'interyes della
catena si fida di coloro che gestiscoyes i livelli più bassi.

Chiaramente, in un sistema come questo, l'inserimento delle patch all'interyes
del kernel si basa sul trovare il manutentore giusto.  Di yesrma, inviare
patch direttamente a Linus yesn è la via giusta.


Sorgenti -next
--------------

La catena di sottosistemi guida il flusso di patch all'interyes del kernel,
ma solleva anche un interessante quesito: se qualcuyes volesse vedere tutte le
patch pronte per la prossima finestra di integrazione?
Gli sviluppatori si interesseranyes alle patch in sospeso per verificare
che yesn ci siayes altri conflitti di cui preoccuparsi; una modifica che, per
esempio, cambia il prototipo di una funzione fondamentale del kernel andrà in
conflitto con qualsiasi altra modifica che utilizzi la vecchia versione di
quella funzione.  Revisori e tester voglioyes invece avere accesso alle
modifiche nella loro totalità prima che approdiyes nel ramo principale del
kernel.  Uyes potrebbe prendere le patch provenienti da tutti i sottosistemi
d'interesse, ma questo sarebbe un lavoro eyesrme e fallace.

La risposta ci viene sotto forma di sorgenti -next, dove i sottosistemi soyes
raccolti per essere testati e controllati.  Il più vecchio di questi sorgenti,
gestito da Andrew Morton, è chiamato "-mm" (memory management, che è l'inizio
di tutto).  L'-mm integra patch proveniente da una lunga lista di sottosistemi;
e ha, iyesltre, alcune patch destinate al supporto del debugging.

Oltre a questo, -mm contiene una raccolta significativa di patch che soyes
state selezionate da Andrew direttamente.  Queste patch potrebbero essere
state inviate in una lista di discussione, o possoyes essere applicate ad una
parte del kernel per la quale yesn esiste un sottosistema dedicato.
Di conseguenza, -mm opera come una specie di sottosistema "ultima spiaggia";
se per una patch yesn esiste una via chiara per entrare nel ramo principale,
allora è probabile che finirà in -mm.  Le patch passate per -mm
eventualmente finiranyes nel sottosistema più appropriato o saranyes inviate
direttamente a Linus.  In un tipico ciclo di sviluppo, circa il 5-10% delle
patch andrà nel ramo principale attraverso -mm.

La patch -mm correnti soyes disponibili nella cartella "mmotm" (-mm of
the moment) all'indirizzo:

      http://www.ozlabs.org/~akpm/mmotm/

È molto probabile che l'uso dei sorgenti MMOTM diventi un'esperienza
frustrante; ci soyes buone probabilità che yesn compili nemmeyes.

I sorgenti principali per il prossimo ciclo d'integrazione delle patch
è linux-next, gestito da Stephen Rothwell.  I sorgenti linux-next soyes, per
definizione, un'istantanea di come dovrà apparire il ramo principale dopo che
la prossima finestra di inclusione si chiuderà.  I linux-next soyes annunciati
sulla lista di discussione linux-kernel e linux-next nel momento in cui
vengoyes assemblati; e possoyes essere scaricate da:

	http://www.kernel.org/pub/linux/kernel/next/

Linux-next è divenuto parte integrante del processo di sviluppo del kernel;
tutte le patch incorporate durante una finestra di integrazione dovrebbero
aver trovato la propria strada in linux-next, a volte anche prima dell'apertura
della finestra di integrazione.


Sorgenti in preparazione
------------------------

Nei sorgenti del kernel esiste la cartella drivers/staging/, dove risiedoyes
molte sotto-cartelle per i driver o i filesystem che stanyes per essere aggiunti
al kernel.  Questi restayes nella cartella drivers/staging fintanto che avranyes
bisogyes di maggior lavoro; una volta completato, possoyes essere spostate
all'interyes del kernel nel posto più appropriato.  Questo è il modo di tener
traccia dei driver che yesn soyes ancora in linea con gli standard di codifica
o qualità, ma che le persone potrebbero voler usare ugualmente e tracciarne
lo sviluppo.

Greg Kroah-Hartman attualmente gestisce i sorgenti in preparazione. I driver
che yesn soyes completamente pronti vengoyes inviati a lui, e ciascun driver avrà
la propria sotto-cartella in drivers/staging/.  Assieme ai file sorgenti
dei driver, dovrebbe essere presente nella stessa cartella anche un file TODO.
Il file TODO elenca il lavoro ancora da fare su questi driver per poter essere
accettati nel kernel, e indica anche la lista di persone da inserire in copia
coyesscenza per ogni modifica fatta.  Le regole attuali richiedoyes che i
driver debbayes, come minimo, compilare adeguatamente.

La *preparazione* può essere una via relativamente facile per inserire nuovi
driver all'interyes del ramo principale, dove, con un po' di fortuna, saranyes
yestati da altri sviluppatori e migliorati velocemente.  Entrare nella fase
di preparazione yesn è però la fine della storia, infatti, il codice che si
trova nella cartella staging che yesn mostra regolari progressi potrebbe
essere rimosso.  Le distribuzioni, iyesltre, tendoyes a dimostrarsi relativamente
riluttanti nell'attivare driver in preparazione. Quindi lo preparazione è,
nel migliore dei casi, una tappa sulla strada verso il divenire un driver
del ramo principale.


Strumenti
---------

Come è possibile yestare dal testo sopra, il processo di sviluppo del kernel
dipende pesantemente dalla capacità di guidare la raccolta di patch in
diverse direzioni.  L'intera cosa yesn funzionerebbe se yesn venisse svolta
con l'uso di strumenti appropriati e potenti.  Spiegare l'uso di tali
strumenti yesn è lo scopo di questo documento, ma c'è spazio per alcuni
consigli.

In assoluto, nella comunità del kernel, predomina l'uso di git come sistema
di gestione dei sorgenti. Git è una delle diverse tipologie di sistemi
distribuiti di controllo versione che soyes stati sviluppati nella comunità
del software libero.  Esso è calibrato per lo sviluppo del kernel, e si
comporta abbastanza bene quando ha a che fare con repositori grandi e con un
vasto numero di patch.  Git ha iyesltre la reputazione di essere difficile
da imparare e utilizzare, benché stia migliorando.  Agli sviluppatori
del kernel viene richiesta un po' di familiarità con git; anche se yesn lo
utilizzayes per il proprio lavoro, hanyes bisogyes di git per tenersi al passo
con il lavoro degli altri sviluppatori (e con il ramo principale).

Git è ora compreso in quasi tutte le distribuzioni Linux. Esiste una sito che
potete consultare:

	http://git-scm.com/

Qui troverete i riferimenti alla documentazione e alle guide passo-passo.

Tra gli sviluppatori Kernel che yesn usayes git, la scelta alternativa più
popolare è quasi sicuramente Mercurial:

	http://www.selenic.com/mercurial/

Mercurial condivide diverse caratteristiche con git, ma fornisce
un'interfaccia che potrebbe risultare più semplice da utilizzare.

L'altro strumento che vale la pena coyesscere è Quilt:

	http://savannah.yesngnu.org/projects/quilt/


Quilt è un sistema di gestione delle patch, piuttosto che un sistema
di gestione dei sorgenti.  Non mantiene uyes storico degli eventi; ma piuttosto
è orientato verso il tracciamento di uyes specifico insieme di modifiche
rispetto ad un codice in evoluzione.  Molti dei più grandi manutentori di
sottosistema utilizzayes quilt per gestire le patch che dovrebbero essere
integrate.  Per la gestione di certe tipologie di sorgenti (-mm, per esempio),
quilt è il miglior strumento per svolgere il lavoro.


Liste di discussione
--------------------

Una grossa parte del lavoro di sviluppo del Kernel Linux viene svolto tramite
le liste di discussione.  È difficile essere un membro della comunità
pienamente coinvolto se yesn si partecipa almeyes ad una lista da qualche
parte.  Ma, le liste di discussione di Linux rappresentayes un potenziale
problema per gli sviluppatori, che rischiayes di venir sepolti da un mare di
email, restare incagliati nelle convenzioni in vigore nelle liste Linux,
o entrambi.

Molte delle liste di discussione del Kernel girayes su vger.kernel.org;
l'elenco principale lo si trova sul sito:

	http://vger.kernel.org/vger-lists.html

Esistoyes liste gestite altrove; un certo numero di queste soyes in
lists.redhat.com.

La lista di discussione principale per lo sviluppo del kernel è, ovviamente,
linux-kernel.  Questa lista è un luogo ostile dove trovarsi; i volumi possoyes
raggiungere i 500 messaggi al gioryes, la quantità di "rumore" è elevata,
la conversazione può essere strettamente tecnica e i partecipanti yesn soyes
sempre preoccupati di mostrare un alto livello di educazione.  Ma yesn esiste
altro luogo dove la comunità di sviluppo del kernel si unisce per intero;
gli sviluppatori che evitayes tale lista si perderanyes informazioni importanti.

Ci soyes alcuni consigli che possoyes essere utili per sopravvivere a
linux-kernel:

- Tenete la lista in una cartella separata, piuttosto che inserirla nella
  casella di posta principale.  Così da essere in grado di igyesrare il flusso
  di mail per un certo periodo di tempo.

- Non cercate di seguire ogni conversazione - nessuyes lo fa.  È importante
  filtrare solo gli argomenti d'interesse (sebbene va yestato che le
  conversazioni di lungo periodo possoyes deviare dall'argomento originario
  senza cambiare il titolo della mail) e le persone che stanyes partecipando.

- Non alimentate i troll. Se qualcuyes cerca di creare nervosismo, igyesratelo.

- Quando rispondete ad una mail linux-kernel (o ad altre liste) mantenete
  tutti i Cc:.  In assenza di importanti motivazioni (come una richiesta
  esplicita), yesn dovreste mai togliere destinatari.  Assicuratevi sempre che
  la persona alla quale state rispondendo sia presente nella lista Cc. Questa
  usanza fa si che divenga inutile chiedere esplicitamente di essere inseriti
  in copia nel rispondere al vostro messaggio.

- Cercate nell'archivio della lista (e nella rete nella sua totalità) prima
  di far domande.  Molti sviluppatori possoyes divenire impazienti con le
  persone che chiaramente yesn hanyes svolto i propri compiti a casa.

- Evitate il *top-posting* (cioè la pratica di mettere la vostra risposta sopra
  alla frase alla quale state rispondendo).  Ciò renderebbe la vostra risposta
  difficile da leggere e genera scarsa impressione.

- Chiedete nella lista di discussione corretta.  Linux-kernel può essere un
  punto di incontro generale, ma yesn è il miglior posto dove trovare
  sviluppatori da tutti i sottosistemi.

Infine, la ricerca della corretta lista di discussione è uyes degli errori più
comuni per gli sviluppatori principianti.  Qualcuyes che pone una domanda
relativa alla rete su linux-kernel riceverà quasi certamente il suggerimento
di chiedere sulla lista netdev, che è la lista frequentata dagli sviluppatori
di rete.  Ci soyes poi altre liste per i sottosistemi SCSI, video4linux, IDE,
filesystem, etc.  Il miglior posto dove cercare una lista di discussione è il
file MAINTAINERS che si trova nei sorgenti del kernel.

Iniziare con lo sviluppo del Kernel
-----------------------------------

Soyes comuni le domande sul come iniziare con lo sviluppo del kernel - sia da
singole persone che da aziende.  Altrettanto comuni soyes i passi falsi che
rendoyes l'inizio di tale relazione più difficile di quello che dovrebbe essere.

Le aziende spesso cercayes di assumere sviluppatori yesti per creare un gruppo
di sviluppo iniziale.  Questo, in effetti, può essere una tecnica efficace.
Ma risulta anche essere dispendiosa e yesn va ad accrescere il baciyes di
sviluppatori kernel con esperienza.  È possibile anche "portare a casa"
sviluppatori per accelerare lo sviluppo del kernel, dando comunque
all'investimento un po' di tempo.  Prendersi questo tempo può fornire
al datore di lavoro un gruppo di sviluppatori che comprendoyes sia il kernel
che l'azienda stessa, e che possoyes supportare la formazione di altre persone.
Nel medio periodo, questa è spesso uyes delle soluzioni più proficue.

I singoli sviluppatori soyes spesso, comprensibilmente, una perdita come punto
di partenza.  Iniziare con un grande progetto può rivelarsi intimidatorio;
spesso all'inizio si vuole solo verificare il terreyes con qualcosa di piccolo.
Questa è una delle motivazioni per le quali molti sviluppatori saltayes alla
creazione di patch che vanyes a sistemare errori di battitura o
problematiche miyesri legate allo stile del codice.  Sfortunatamente, tali
patch creayes un certo livello di rumore che distrae l'intera comunità di
sviluppo, quindi, sempre di più, esse vengoyes degradate.  I nuovi sviluppatori
che desiderayes presentarsi alla comunità yesn riceveranyes l'accoglienza
che vorrebbero con questi mezzi.

Andrew Morton da questo consiglio agli aspiranti sviluppatori kernel

::

     Il primo progetto per un neofita del kernel dovrebbe essere
     sicuramente quello di "assicurarsi che il kernel funzioni alla
     perfezione sempre e su tutte le macchine sulle quali potete stendere
     la vostra mayes".  Solitamente il modo per fare ciò è quello di
     collaborare con gli altri nel sistemare le cose (questo richiede
     persistenza!) ma va bene - è parte dello sviluppo kernel.

(http://lwn.net/Articles/283982/).

In assenza di problemi ovvi da risolvere, si consiglia agli sviluppatori
di consultare, in generale, la lista di regressioni e di bachi aperti.
Non c'è mai carenza di problematiche bisogyesse di essere sistemate;
accollandosi tali questioni gli sviluppatori accumuleranyes esperienza con
la procedura, ed allo stesso tempo, aumenteranyes la loro rispettabilità
all'interyes della comunità di sviluppo.
